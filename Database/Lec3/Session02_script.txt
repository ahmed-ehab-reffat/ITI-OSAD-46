-- --------------------------------------------------------------

set autocommit = 0;

-- DMLs [insert, update, delete] >> Transaction Control [ Commit - Rollback ]

-- 1. insert
-- example : insert new dept [280, Data Science, 109, 1400 ]
-- --			insert new employee [ 207, your data, hire date = 24-4-2022,
-- 						comm = null | job id = it prog	| dept id = 280 ]

insert into departments
	(department_id, department_name, manager_id, location_id )
values
	(280, 'Data Science', 109, 1400 );
-- Test
select * from departments;
-- Apply 
commit;

-- insert New employee		_   24-4-2022					now()
insert into employees
	(employee_id, first_name, last_name, email, 
    phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id )
values
	(207, 'Yaiha', 'Momtaz', 'yahia@gmail.com', '01274077377', 
    str_to_date('24-4-2022', '%d-%m-%Y'), 'IT_PROG', 9000, null, 105, 280);

-- test
select * from employees;

-- apply
commit;


-- 2- Update 
-- example : employee date no 207
-- --			 comm = 0.5, phone = null,	salary + 2000
-- --		     email = Yahia.Momtaz.207@gmail.com
-- --			 department = IT

update employees
set commission_pct = 0.5,
	phone_number = null,
    salary = salary + 2000,
    email = concat(first_name, '.', last_name, '.', employee_id, '@gmail.com'),
    department_id = (select department_id from departments where department_name = 'Data Science')
where employee_id = 207;

-- Test
select * from employees;

-- apply
commit;

-- 3. delete 
-- example : delete department no 280
delete from employees
where department_id = 280;

delete from departments
where department_id = 280;

-- test 
select * from employees;
select * from departments;

-- undo
rollback;






-- SQL Functions : Aggregate Functions
-- example : show the use of aggregate functions : sum, max, min, count 				avg
select sum(salary), max(salary), min(salary), count(*)
from employees;

-- example : use all aggregate functions but for dept = 30
select sum(salary), max(salary), min(salary), count(*)
from employees
where department_id = 30;




-- Error ## donot put a column beside aggregated functions
/*
select sum(salary), max(salary), min(salary), count(*), last_name
from employees;
*/






-- # Group by : to categorize data  |  Having to filter aggregated functions
-- example : 1. show sum of employees salary per each department (Grouping by Department )

--    2.exclude employees with null dept,
-- 	  3.exclude departments with count(*) = 1

select department_id, sum(salary) as sum_sal, count(*)		-- 5
from employees												-- 1
where department_id is not null								-- 2
group by department_id										-- 3
having count(*) > 1											-- 4
order by department_id asc;									-- 6

-- example : show aggregated functions per each department and per each job
-- Nested group by [ Drilling ]
select department_id, job_id, sum(salary), count(*)
from employees
group by department_id, job_id
order by department_id asc;


-- example : show sum of salary for dept id = 40 beside dept id 
select department_id, sum(salary)
from employees
where department_id = 40
group by department_id;



-- avg () example : show the special case of avg function
select avg( coalesce(salary, 0) ), sum(salary) / count(*)
from employees;



-- ----------------------------------------------------
--  Join Between Tables -- 
/*
 1- inner join  [ 1st syntax | 2nd syntax ]
 2- outer join
 3- self join [ recursive ] [unary relationship]
*/
-- 1. inner join [ 1st syntax ]
-- example (2 tables): show employees data ... , beside department_name
select employee_id, last_name, salary, employees.department_id, department_name
from employees, departments
where employees.department_id = departments.department_id		-- join condition
order by employee_id asc;

-- example (3 tables): show employees data , beside department_name, beside city
select employee_id, last_name, salary, employees.department_id, department_name,
		departments.location_id, city
from employees, departments, locations
where employees.department_id = departments.department_id		-- join condition
and departments.location_id = locations.location_id
order by employee_id asc;



-- 2nd syntax 
-- example (2 tables): show employees data ... , beside department_name
select employee_id, last_name, salary, employees.department_id, department_name
from employees inner join departments
ON employees.department_id = departments.department_id		-- join condition
where salary <= 7000
order by employee_id asc;



-- example (3 tables): show employees data , beside department_name, beside city
select employee_id, last_name, salary, employees.department_id, department_name,
		departments.location_id, city
from employees inner join departments
ON employees.department_id = departments.department_id		-- join condition
inner join locations
On departments.location_id = locations.location_id			-- join condition
where salary <= 7000
order by employee_id asc;



-- when Cross Join [ bad join ] [Cartesian Product ] can be happened ? 
/*
select employee_id, last_name, salary, employees.department_id, department_name
from employees, departments;
*/




-- ## 2. Outer Join Type ## --
-- show employees data beside dept name [ and show also employees with no dept  ]  		
-- 		inner			1
--		Left			1,  2			>>>>>> 
--		Right			1,  3
--		Full		    1,	2,	3		( not in mysql db ) 
select employee_id, last_name, salary,
	   departments.department_id,  department_name
from employees Left Outer Join departments
On employees.department_id = departments.department_id;


-- ## 3. Self Join [ Recursive ] | Unary Relationship 
-- ex : Categories | Sub Categories | Sub Categories .. in E commerce websites
-- ex : شجرة الحسابات  GL
-- example : show employees data [ last_name, salary ]
--           beside his supervisor [ last_name, salary ]
select emps.last_name as emp_name, emps.salary as emp_salary,
	    mgrs.last_name as mgr_name, mgrs.salary as mgr_salary
from employees emps, employees mgrs
where emps.manager_id = mgrs.employee_id;



-- self join with outer join 
select emps.last_name as emp_name, emps.salary as emp_salary,
	    mgrs.last_name as mgr_name, mgrs.salary as mgr_salary
from employees emps Left Outer Join employees mgrs
ON emps.manager_id = mgrs.employee_id;


-- ###### Subquery #######
-- 1] Single Row Subquery   =     >     <    >=     <=    != 
-- Query inside another Query 
-- example : show all employees data works in dept ( the same dept for emp no 115 )
select *
from employees
where department_id = (select department_id from employees where employee_id = 115)
and employee_id != 115;


-- example : Show employee with first name = Alexander , last name Khoo
select *
from employees
where department_id = ( select department_id from employees
					where first_name = 'Alexander' and last_name = 'Khoo');

-- example : Show Employees who have the Max Salary 
select *
from employees
where salary = (select max(salary) from employees);

-- example : Show Employees who work in dept (The department with name = IT)
select *
from employees
where department_id = (select department_id from departments where department_name = 'IT');





-- 2] Multi Row Sub Query       in      		 Any    All 
-- example : show departments data which have employees
select *
from departments
where department_id in ( select department_id from employees);
                        
-- example : show departments data which have no employees  
-- NOT IN : != ALL				note		 remove null from sub query
select *
from departments
where department_id Not in ( select coalesce(department_id, 0) from employees);


   
-- example : show employees who have salary > ALL salaries of employees in dept 30
--	-- 	> ALL			> MAX		> 11000
select *
from employees
where salary >ALL (select salary from employees where department_id = 30);


-- example : show employees who have salary > ANY salaries of employees in dept 30
--	-- 	> Any			> Min		> 2500
select *
from employees
where salary >ANY (select salary from employees where department_id = 30);


-- -- Correlated SubQuery	( self stydy ) 


-- ## Union 
select employee_id, last_name, salary, job_id
from employees
where department_id = 30
Union
select employee_id, last_name, 0, ''
from employees
where department_id = 60;

--

select 0 as department_id, 'ALL' as department_name
Union
select department_id, department_name
from departments
order by department_id asc;


